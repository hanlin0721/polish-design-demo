/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from "react";
import { useGLTF, useAnimations, useTexture } from "@react-three/drei";
import { useEffect, useState } from "react";
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import useControl from "../../store/useControl.js";
import gsap from "gsap";
import Test from "./Test.js";
import { useDeviceType } from "../../utils/window.js"

// const baseUrl = "https://polish-design-demo.zeabur.app"
// const baseUrl = "http://localhost:3000"

export default function City(props) {
    const [device] = useDeviceType()
    const group = useRef();
    const polishManHiddenRef = useRef()
    const polishManShowedRef = useRef()
    const polishManFloatingRef = useRef()
    const groundRef = useRef()
    const buildingRef = useRef()
    const othersBuildingRef = useRef()
    const whloeMap = useRef()

    const projectTestRef = useRef()
    const projectTestGroupRef = useRef()
    const projectCSOnlineRef = useRef()

    const rawNFreshMeshRef = useRef()
    const projectRawNFreshRef = useRef()

    const fourDesireMeshRef = useRef()
    const projectFourDesireRef = useRef()

    const [smoothCameraPosition] = useState(() => new THREE.Vector3())
    const [smoothCameraTarget] = useState(() => new THREE.Vector3())

    const { nodes, animations } = useGLTF(`./230206_city.glb`)

    const { actions } = useAnimations(animations, group);

    const bakedGroundTexture = useTexture(`./20230120_ground.png`)
    bakedGroundTexture.flipY = false

    const bakedHousesTexture = useTexture(`./20230120_houses.png`)
    bakedHousesTexture.flipY = false

    const bakedHouseOTexture = useTexture(`./230120_houses_O.png`)
    bakedHouseOTexture.flipY = false

    const bakedA01Texture = useTexture(`./A01.png`)
    bakedA01Texture.flipY = false

    const bakedA02Texture = useTexture(`./A02.png`)
    bakedA02Texture.flipY = false

    const bakedA03Texture = useTexture(`./A03.png`)
    bakedA03Texture.flipY = false

    const bakedA04Texture = useTexture(`./A04.png`)
    bakedA04Texture.flipY = false

    const bakedA05Texture = useTexture(`./A05.png`)
    bakedA05Texture.flipY = false

    const bakedA06Texture = useTexture(`./A06.png`)
    bakedA06Texture.flipY = false

    const bakedA07Texture = useTexture(`./A07.png`)
    bakedA07Texture.flipY = false

    const bakedA08Texture = useTexture(`./A08.png`)
    bakedA08Texture.flipY = false

    const bakedA09Texture = useTexture(`./A09.png`)
    bakedA09Texture.flipY = false

    const bakedA10Texture = useTexture(`./A10.png`)
    bakedA10Texture.flipY = false

    const bakedA15Texture = useTexture(`./A15.png`)
    bakedA15Texture.flipY = false

    const bakedA19Texture = useTexture(`./A19.png`)
    bakedA19Texture.flipY = false

    const bakedA20Texture = useTexture(`./A20.png`)
    bakedA20Texture.flipY = false

    const bakedRoadTexture = useTexture(`./20230120_road.png`)
    bakedRoadTexture.flipY = false

    const bakedPolishManBlueTexture = useTexture(`./blue.png`)
    bakedPolishManBlueTexture.flipY = false

    const bakedPolishManGreenTexture = useTexture(`./polish-man002.png`)
    bakedPolishManGreenTexture.flipY = false

    const { scene, scenes, scroll } = useControl(state => state)

    useEffect(() => {
        const unsubscribeReset = useControl.subscribe(
            (state) => state.scene,
            (value) => {
                console.log('value', value)
                // if (value === scenes.LOOKING_BLUE_POLISH_MAN) {
                //     gsap.to(buildingRef.current.material, {
                //         opacity: 1,
                //     })
                //     gsap.to(othersBuildingRef.current.material, {
                //         opacity: 1,
                //     })
                //     gsap.to(fourDesireMeshRef.current.material, {
                //         opacity: 1,
                //     })
                //     gsap.to(rawNFreshMeshRef.current.material, {
                //         opacity: 1,
                //     })
                //     actions.Animation.reset()
                //     actions.Animation.play()
                // }
                // if (value === scenes.LOOKING_FLOATING_BLUE_POLISH_MAN) {
                // gsap.to(buildingRef.current.material, {
                //     opacity: 0,
                // })
                // gsap.to(othersBuildingRef.current.material, {
                //     opacity: 0,
                // })
                // gsap.to(fourDesireMeshRef.current.material, {
                //     opacity: 0,
                // })
                // gsap.to(rawNFreshMeshRef.current.material, {
                //     opacity: 0,
                // })
                // }
                if (value === scenes.LOOKING_PORTFOLIO) {
                    gsap.to(buildingRef.current.material, {
                        opacity: 1,
                    })
                }
            }
        )

        actions.Animation.play()

        return () => {
            unsubscribeReset()
        }
    }, [])


    // const polishManShowedFollowingHiddenOne = () => {
    //     const position = new THREE.Vector3(-0.025, 0.08, 0)
    //     position.applyQuaternion(polishManHiddenRef.current.quaternion)
    //     position.add(new THREE.Vector3(polishManHiddenRef.current.position.x, polishManHiddenRef.current.position.y, polishManHiddenRef.current.position.z))

    //     polishManShowedRef.current.position.copy(position)
    //     polishManShowedRef.current.rotation.copy(polishManHiddenRef.current.rotation)
    // }

    const cameraFollow = ({
        objRef,
        initialPosition,
        initialTarget
    }) => {
        const cameraPosition = initialPosition
        cameraPosition.applyQuaternion(objRef.current.quaternion)
        cameraPosition.add(new THREE.Vector3(
            objRef.current.position.x,
            objRef.current.position.y,
            objRef.current.position.z,
        ))

        const cameraTarget = initialTarget
        cameraTarget.applyQuaternion(objRef.current.quaternion)
        cameraTarget.add(new THREE.Vector3(
            objRef.current.position.x,
            objRef.current.position.y,
            objRef.current.position.z,
        ))

        return {
            cameraPosition,
            cameraTarget
        }
    }


    useFrame((state, delta) => {

        if (scene === scenes.LOOKING_BLUE_POLISH_MAN) {

            const cameraPosition = new THREE.Vector3(
                device !== "desktop" ? -28 : -6.5,
                device !== "desktop" ? 30 : 20,
                device !== "desktop" ? -30 : -20
            )
            const cameraTarget = new THREE.Vector3(
                device !== "desktop" ? -8 : -3,
                device !== "desktop" ? -2 : -0,
                device !== "desktop" ? 0 : 0
            )

            smoothCameraPosition.lerp(cameraPosition, 4.2 * delta)
            smoothCameraTarget.lerp(cameraTarget, 4.2 * delta)

            state.camera.position.copy(smoothCameraPosition)
            state.camera.lookAt(smoothCameraTarget)
        }

        if (scene === scenes.LOOKING_FLOATING_BLUE_POLISH_MAN) {

            const cameraPosition = new THREE.Vector3(-21.6, 8.5, -19.44)
            const cameraTarget = new THREE.Vector3(-5, 6, 2)

            smoothCameraPosition.lerp(cameraPosition, 4.2 * delta)
            smoothCameraTarget.lerp(cameraTarget, 4.2 * delta)

            state.camera.position.copy(smoothCameraPosition)
            state.camera.lookAt(smoothCameraTarget)
            // const cameraPosition = new THREE.Vector3(
            //     polishManFloatingRef.current.position.x + (device !== "desktop" ? 0.3 : 0.18) + state.pointer.x * 0.01,
            //     polishManFloatingRef.current.position.y + state.pointer.y * 0.01,
            //     polishManFloatingRef.current.position.z + (device !== "desktop" ? 0.9 : 0.38)
            // )
            // const cameraTarget = new THREE.Vector3(
            //     polishManFloatingRef.current.position.x - (device !== "desktop" ? 0.08 : 0.09),
            //     polishManFloatingRef.current.position.y - (device !== "desktop" ? -0.05 : 0.01),
            //     polishManFloatingRef.current.position.z + (device !== "desktop" ? 0 : 0)
            // )

            // smoothCameraPosition.lerp(cameraPosition, 4.2 * delta)
            // smoothCameraTarget.lerp(cameraTarget, 4.2 * delta)

            // state.camera.position.copy(smoothCameraPosition)
            // state.camera.lookAt(smoothCameraTarget)
        }

        if (scene === scenes.LOOKING_PORTFOLIO) {
            const { cameraPosition, cameraTarget } = cameraFollow({
                objRef: polishManHiddenRef,
                initialPosition: new THREE.Vector3(-3, 6.5, -5),

                initialTarget: new THREE.Vector3(
                    device !== "desktop" ? -0 : -0,
                    device !== "desktop" ? 0.3 : 0,
                    device !== "desktop" ? -0.2 : 0
                )
            })

            smoothCameraPosition.lerp(cameraPosition, 4.2 * delta)
            smoothCameraTarget.lerp(cameraTarget, 4.2 * delta)

            state.camera.position.copy(smoothCameraPosition)
            state.camera.lookAt(smoothCameraTarget)
        }

        if (scene === "412c67d3913547108916a69423a1958e") {
            const cameraPosition = new THREE.Vector3(
                projectFourDesireRef.current.position.x - (device !== "desktop" ? 1.7 : 1.5),
                projectFourDesireRef.current.position.y,
                projectFourDesireRef.current.position.z - (device !== "desktop" ? 0.1 : 1)
            )

            const cameraTarget = new THREE.Vector3(
                projectFourDesireRef.current.position.x + 2,
                projectFourDesireRef.current.position.y,
                projectFourDesireRef.current.position.z
            )

            smoothCameraPosition.lerp(cameraPosition, 4.2 * delta)
            smoothCameraTarget.lerp(cameraTarget, 4.2 * delta)

            state.camera.position.copy(smoothCameraPosition)
            state.camera.lookAt(smoothCameraTarget)
        }

        if (scene === "cc") {
            projectTestRef.current.geometry.center()
            projectTestGroupRef.current.rotation.y += ((scroll * 4 / 1730) - projectTestGroupRef.current.rotation.y) * 0.1
            projectTestGroupRef.current.position.copy(projectCSOnlineRef.current.position)

            const cameraPosition = new THREE.Vector3(
                projectCSOnlineRef.current.position.x - (device !== "desktop" ? 1 : 1),
                projectCSOnlineRef.current.position.y,
                projectCSOnlineRef.current.position.z - (device !== "desktop" ? 0.5 : 1),
            )

            const cameraTarget = new THREE.Vector3(
                projectCSOnlineRef.current.position.x,
                projectCSOnlineRef.current.position.y,
                projectCSOnlineRef.current.position.z - (device !== "desktop" ? -0.025 : 0.5)
            )

            smoothCameraPosition.lerp(cameraPosition, 4.2 * delta)
            smoothCameraTarget.lerp(cameraTarget, 4.2 * delta)

            state.camera.position.copy(smoothCameraPosition)
            state.camera.lookAt(smoothCameraTarget)
        }

        if (scene === "c785970d9f0949df9e6fcd77a33ff7e4") {
            const cameraPosition = new THREE.Vector3(
                projectRawNFreshRef.current.position.x + 1.2,
                projectRawNFreshRef.current.position.y,
                projectRawNFreshRef.current.position.z + 1
            )

            const cameraTarget = new THREE.Vector3(
                projectRawNFreshRef.current.position.x + (device !== "desktop" ? 0 : -2),
                projectRawNFreshRef.current.position.y,
                projectRawNFreshRef.current.position.z
            )

            smoothCameraPosition.lerp(cameraPosition, 4.2 * delta)
            smoothCameraTarget.lerp(cameraTarget, 4.2 * delta)

            state.camera.position.copy(smoothCameraPosition)
            state.camera.lookAt(smoothCameraTarget)
        }



    })

    return (
        <group ref={group} {...props} dispose={null}>
            <group ref={whloeMap} name="Scene">
                <mesh
                    ref={groundRef}
                    name="ground"
                    castShadow
                    receiveShadow
                    geometry={nodes.ground.geometry}
                    material={nodes.ground.material}
                    position={[-6.22, 0.28, 1.13]}
                >
                    <meshBasicMaterial
                        map={bakedGroundTexture}
                    />
                </mesh>

                {/* 4 Desire */}
                <mesh visible={false} ref={projectFourDesireRef} position={[-0, 0.3, 1.45]} rotation-y={1}>
                    <boxGeometry args={[0.25, 0.25, 0.25]} />
                    <meshBasicMaterial color="red" />
                </mesh>
                <mesh
                    ref={fourDesireMeshRef}
                    name="A01"
                    castShadow
                    receiveShadow
                    geometry={nodes["A01"].geometry}
                    material={nodes["A01"].material}
                    position={[0, 0.03, 0]}
                    rotation={[Math.PI / 2, 0, 0]}
                >
                    <meshBasicMaterial map={bakedA01Texture} transparent={true} />
                </mesh>

                {/* 沙西米 */}
                <mesh visible={false} ref={projectRawNFreshRef} position={[-1.45, 0.19, 1.17]} rotation-y={Math.PI * 0.25}>
                    <boxGeometry args={[0.25, 0.25, 0.25]} />
                    <meshBasicMaterial color="red" />
                </mesh>
                <mesh
                    ref={rawNFreshMeshRef}
                    name="A02"
                    castShadow
                    receiveShadow
                    geometry={nodes.A02.geometry}
                    material={nodes.A02.material}
                    position={[0, -0.09, 0]}
                    rotation={[Math.PI / 2, 0, 0]}
                >
                    <meshBasicMaterial map={bakedA02Texture} transparent={true} />
                </mesh>

                {/* CSO */}
                <mesh visible={false} ref={projectCSOnlineRef} position={[-1.5, 0.12, 4.1]} rotation-y={Math.PI * 1.3}>
                    <boxGeometry args={[0.25, 0.25, 0.25]} />
                    <meshBasicMaterial color="red" />
                </mesh>
                <group ref={projectTestGroupRef}>
                    <mesh
                        ref={projectTestRef}
                        name="A03"
                        castShadow
                        receiveShadow
                        geometry={nodes.A03.geometry}
                        material={nodes.A03.material}
                        position={[0, 0.03, 0]}
                        rotation={[Math.PI / 2, 0, 0]}
                    >
                        <meshBasicMaterial map={bakedA03Texture} transparent={true} />
                    </mesh>
                </group>

                {/* WASSUP */}
                <mesh visible={false} position={[-3.3, 0.49, 4.6]} rotation-y={Math.PI * 0.25}>
                    <boxGeometry args={[0.25, 0.25, 0.25]} />
                    <meshBasicMaterial color="red" />
                </mesh>
                <mesh
                    name="A04"
                    castShadow
                    receiveShadow
                    geometry={nodes.A04.geometry}
                    material={nodes.A04.material}
                    position={[-3.27, 0.17, 4.61]}
                >
                    <meshBasicMaterial map={bakedA04Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A05"
                    castShadow
                    receiveShadow
                    geometry={nodes.A05.geometry}
                    material={nodes.A05.material}
                    position={[-2.49, 0.44, 6.34]}
                >
                    <meshBasicMaterial map={bakedA05Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A06"
                    castShadow
                    receiveShadow
                    geometry={nodes.A06.geometry}
                    material={nodes.A06.material}
                    position={[-3.56, 0.26, 7.56]}
                >
                    <meshBasicMaterial map={bakedA06Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A07"
                    castShadow
                    receiveShadow
                    geometry={nodes.A07.geometry}
                    material={nodes.A07.material}
                    position={[-4.65, 0.19, 6.62]}
                >
                    <meshBasicMaterial map={bakedA07Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A08"
                    castShadow
                    receiveShadow
                    geometry={nodes.A08.geometry}
                    material={nodes.A08.material}
                    position={[-6.75, 0.34, 8.65]}
                >
                    <meshBasicMaterial map={bakedA08Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A09"
                    castShadow
                    receiveShadow
                    geometry={nodes.A09.geometry}
                    material={nodes.A09.material}
                    position={[-7.93, 0.31, 9.84]}
                >
                    <meshBasicMaterial map={bakedA09Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A10"
                    castShadow
                    receiveShadow
                    geometry={nodes.A10.geometry}
                    material={nodes.A10.material}
                    position={[-10.18, 0.57, 9.75]}
                >
                    <meshBasicMaterial map={bakedA10Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A15"
                    castShadow
                    receiveShadow
                    geometry={nodes.A15.geometry}
                    material={nodes.A15.material}
                    position={[-8.6, 0.32, -0.14]}
                >
                    <meshBasicMaterial map={bakedA15Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A19"
                    castShadow
                    receiveShadow
                    geometry={nodes.A19.geometry}
                    material={nodes.A19.material}
                    position={[-4.11, 0.34, -0.23]}
                >
                    <meshBasicMaterial map={bakedA19Texture} transparent={true} />
                </mesh>

                <mesh
                    name="A20"
                    castShadow
                    receiveShadow
                    geometry={nodes.A20.geometry}
                    material={nodes.A20.material}
                    position={[-2.6, 0.34, -0.3]}
                >
                    <meshBasicMaterial map={bakedA20Texture} transparent={true} />
                </mesh>

                <mesh
                    ref={buildingRef}
                    name="houses"
                    castShadow
                    receiveShadow
                    geometry={nodes.houses.geometry}
                    material={nodes.houses.material}
                    position={[-4.43, 0.55, 5.9]}
                >
                    <meshBasicMaterial map={bakedHousesTexture} transparent={true} />
                </mesh>
                <mesh
                    ref={othersBuildingRef}
                    name="houses_O"
                    castShadow
                    receiveShadow
                    geometry={nodes.houses_O.geometry}
                    material={nodes.houses_O.material}
                    position={[-3.27, 0.13, 4.61]}
                >

                    <meshBasicMaterial map={bakedHouseOTexture} transparent={true} />
                </mesh>
                <mesh
                    name="road"
                    castShadow
                    receiveShadow
                    geometry={nodes.road.geometry}
                    material={nodes.road.material}
                    position={[-6.52, -0.47, 4.86]}
                    scale={[81.54, 36.47, 66.14]}
                >
                    <meshBasicMaterial map={bakedRoadTexture} />
                </mesh>

                {/* 磨人雕像 */}
                <mesh
                    name="polish-man002"
                    castShadow
                    receiveShadow
                    geometry={nodes["polish-man002"].geometry}
                    material={nodes["polish-man002"].material}
                    position={[-8.63, 0.33, 6.71]}
                    rotation={[-2.23, -1.15, -2.69]}
                    scale={1.79}
                >
                    {/* <meshBasicMaterial map={bakedPolishManGreenTexture} /> */}
                </mesh>

                <mesh
                    visible={false}
                    ref={polishManHiddenRef}
                    name="polish-man001"
                    castShadow
                    receiveShadow
                    geometry={nodes["polish-man001"].geometry}
                    material={nodes["polish-man001"].material}
                    rotation={[0, -Math.PI / 6, 0]}
                    scale={0.14}
                />

                {/* 實際要顯示的磨人 */}
                <Test
                    visible={false}
                    ref={polishManShowedRef}
                    groupRotation={[0, -Math.PI / 6, 0]}
                    rotation={[2.2 * Math.PI, 0, 0]}
                    isSpinning={true}
                >
                    {/* <meshBasicMaterial map={bakedPolishManBlueTexture} /> */}
                    {/* <meshStandardMaterial map={bakedPolishManBlueTexture} /> */}
                </Test>

                {/* 實際要顯示的磨人 原地漂浮-藍色 */}
                {/* <Test
                    visible={scene == 2}
                    ref={polishManFloatingRef}
                    position={[-0.55, 0.13, 1.3]}
                    rotation={[2.15 * Math.PI, 2.12 * Math.PI, 2.21 * Math.PI]}
                >
                </Test> */}
            </group>
        </group>
    );
}

useGLTF.preload(`./230206_city.glb`);
