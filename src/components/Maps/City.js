/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from "react";
import { useGLTF, useAnimations, useTexture, Html, Clone, Float } from "@react-three/drei";
import { useEffect, useState } from "react";
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import useControl from "../../store/useControl.js";
import gsap from "gsap";
import appStore from "../../store/store.js";
import PolishMan from "./PolishMan.js";

export default function City(props) {
    const group = useRef();
    const polishManRef = useRef()
    const polishManOneRef = useRef()
    const polishManTwoRef = useRef()
    const buildingRef = useRef()
    const buildingOneRef = useRef()
    const floorRef = useRef()

    const [smoothCameraPosition] = useState(() => new THREE.Vector3())
    const [smoothCameraTarget] = useState(() => new THREE.Vector3())

    const { nodes, animations } = useGLTF("./city.glb")

    const { actions } = useAnimations(animations, group);

    const bakedBaseTexture = useTexture('./base.png')
    bakedBaseTexture.flipY = false

    const bakedArcTexture = useTexture('./build.png')
    bakedArcTexture.flipY = false

    const bakedPolishManOrangeTexture = useTexture('./orange.png')
    bakedPolishManOrangeTexture.flipY = false

    const bakedPolishManWhiteTexture = useTexture('./white.png')
    bakedPolishManWhiteTexture.flipY = false

    const bakedPolishManBlueTexture = useTexture('./blue.png')
    bakedPolishManBlueTexture.flipY = false

    const [scene, setScene] = useState(1)

    useEffect(() => {
        const unsubscribeReset = useControl.subscribe(
            (state) => state.scene,
            (value) => {
                console.log(value)
                if (value === 1) {
                    setScene(() => 1)
                    appStore.scene = 1

                    gsap.to(buildingRef.current.material, {
                        opacity: 1,
                    })
                    gsap.to(buildingOneRef.current.material, {
                        opacity: 1,
                    })
                }
                if (value === 2) {
                    appStore.scene = 2
                    setScene(() => 2)

                    gsap.to(buildingRef.current.material, {
                        opacity: 0,
                    })
                    gsap.to(buildingOneRef.current.material, {
                        opacity: 0,
                    })
                }
                if (value === 3) {
                    setScene(() => 3)
                    appStore.scene = 3

                    gsap.to(buildingRef.current.material, {
                        opacity: 1,
                    })
                    gsap.to(buildingOneRef.current.material, {
                        opacity: 1,
                    })
                }
            }
        )

        actions.Animation.play()

        return () => {
            unsubscribeReset()
        }
    }, [])

    useFrame((state, delta) => {
        let cameraPosition
        let cameraTarget

        if (scene === 1 || scene === 3) {
            cameraPosition = new THREE.Vector3(-1, 1.2, -1.2)
            cameraPosition.applyQuaternion(polishManRef.current.quaternion)
            cameraPosition.add(new THREE.Vector3(
                polishManRef.current.position.x,
                polishManRef.current.position.y,
                polishManRef.current.position.z,
            ))

            cameraTarget = new THREE.Vector3(
                -0.7,
                0,
                0.8
            )
            cameraTarget.applyQuaternion(polishManRef.current.quaternion)
            cameraTarget.add(new THREE.Vector3(
                polishManRef.current.position.x,
                polishManRef.current.position.y,
                polishManRef.current.position.z,
            ))
        }

        if (scene === 2) {
            cameraPosition = new THREE.Vector3(
                polishManTwoRef.current.position.x + 0,
                polishManTwoRef.current.position.y + 0,
                polishManTwoRef.current.position.z + 0.4
            )
            cameraTarget = new THREE.Vector3(
                polishManTwoRef.current.position.x - 0.1,
                polishManTwoRef.current.position.y,
                polishManTwoRef.current.position.z + 0
            )
        }

        smoothCameraPosition.lerp(cameraPosition, 5 * delta)
        smoothCameraTarget.lerp(cameraTarget, 5 * delta)

        const test = new THREE.Vector3(0.05, 0.08, 0)
        test.applyQuaternion(polishManRef.current.quaternion)
        test.add(new THREE.Vector3(polishManRef.current.position.x, polishManRef.current.position.y, polishManRef.current.position.z))

        polishManOneRef.current.position.copy(test)
        polishManOneRef.current.rotation.copy(polishManRef.current.rotation)

        state.camera.position.copy(smoothCameraPosition)
        state.camera.lookAt(smoothCameraTarget)
    })

    return (
        <group ref={group} {...props} dispose={null}>
            <group name="Scene">
                <mesh
                    ref={floorRef}
                    name="BASE"
                    castShadow
                    receiveShadow
                    geometry={nodes.BASE.geometry}
                    material={nodes.BASE.material}
                    position={[-6.15, 0.28, 1.12]}
                >
                    <meshBasicMaterial
                        map={scene === 2 ? bakedBaseTexture : null}
                        color={scene === 2 ? "#fff" : null}
                    />
                </mesh>
                <mesh
                    ref={buildingOneRef}
                    name="B_01"
                    castShadow
                    receiveShadow
                    geometry={nodes.B_01.geometry}
                    material={nodes.B_01.material}
                    position={[-6.54, 0.18, 2.9]}
                >
                    <meshBasicMaterial map={bakedArcTexture} transparent={true} />
                    {/* <Html
                        transform
                        wrapperClass="htmlScreen"
                        distanceFactor={1}
                    // position={[0.8, -0.2, -1]}
                    // rotation-y={2 * Math.PI}
                    >
                        <iframe src="https://bruno-simon.com/html/" />
                    </Html> */}
                </mesh>
                <mesh
                    name="ROADDD"
                    castShadow
                    receiveShadow
                    geometry={nodes.ROADDD.geometry}
                    material={nodes.ROADDD.material}
                    position={[-6.45, -0.47, 4.85]}
                    scale={[81.54, 36.47, 66.14]}
                />
                <mesh
                    ref={buildingRef}
                    name="ARC"
                    castShadow
                    receiveShadow
                    geometry={nodes.ARC.geometry}
                    material={nodes.ARC.material}
                    position={[-6.54, 0.18, 2.9]}
                >
                    <meshBasicMaterial map={bakedArcTexture} transparent={true} />
                </mesh>

                {/* 會動的磨人 (隱藏) */}
                <mesh
                    visible={false}
                    ref={polishManRef}
                    name="polish-man001"
                    castShadow
                    receiveShadow
                    geometry={nodes["polish-man001"].geometry}
                    material={nodes["polish-man001"].material}
                    rotation={[0, -Math.PI / 6, 0]}
                    position={[0, 0, 0]}
                    scale={0.14}
                />

                {/* 實際要顯示的磨人 */}
                <PolishMan
                    visible={scene == 1}
                    ref={polishManOneRef}
                    groupRotation={[0, -Math.PI / 6, 0]}
                    rotation={[2.2 * Math.PI, 0, 0]}
                    isSpinning={true}
                >
                    <meshBasicMaterial map={bakedPolishManBlueTexture} transparent={true} />
                </PolishMan>

                {/* 實際要顯示的磨人 原地旋轉 */}
                {/* <Float> */}
                <PolishMan
                    visible={scene == 2}
                    ref={polishManTwoRef}
                    position={[-0.5, 0.1, 1.2]}
                    rotation={[2.1 * Math.PI, 2 * Math.PI, 2.3 * Math.PI]}
                >
                    <meshBasicMaterial map={bakedPolishManBlueTexture} />
                </PolishMan>

                <PolishMan
                    visible={scene == 2}
                    position={[-0.46, 0.06, 1.41]}
                    rotation={[1.95 * Math.PI, 2.1 * Math.PI, 2.3 * Math.PI]}
                >
                    <meshBasicMaterial map={bakedPolishManWhiteTexture} />
                </PolishMan>

                {/* <PolishMan
                    // visible={scene == 2}
                    position={[-0.6, 0.1, 0.8]}
                    rotation={[2.1 * Math.PI, 2 * Math.PI, 2.3 * Math.PI]}
                >
                    <meshBasicMaterial map={bakedPolishManOrangeTexture} />
                </PolishMan> */}
                {/* </Float> */}

            </group>
        </group>
    );
}

useGLTF.preload("./city.glb");
